#ifndef __ROSE_COLOR_PATCH_HPP__
#define __ROSE_COLOR_PATCH_HPP__

/**
 * Rose curve (rhodonea) is a curve in 2D space generated by
 * plotting a sine wave in polar coordinates. Think of it as multiplying
 * sine by a complex quadrature . More details at
 * http://xahlee.info/SpecialPlaneCurves_dir/Rose_dir/rose.html
 *
 * For comparison, multiplying two real signals wood give us good old
 * ring modulatttion
 *
 * Param A sets tuning, buttons choose submenu
 *
 * Main menu:
 * - param B morphs a pure complex sine into a rose
 * - params C and D set harmonic relationtionship, where internal modulator
 * has frequency determind as C divided by D
 * - when D == 0, internal oscillator is freerunning and you can get
 * inharmonic partials. Getting close to harmonic ratio gives you beating effect.
 *
 * Submenu 1 controls feedback in the oscillator:
 * - param B sets internal sine oscillator feedback. If your rose has two layers
 * of petals, this moves them relative to each other
 * - param C sets direction (polar phase) for complex oscillator's feedback. This
 * determines where feedback warping is directed.
 * - param D adds feedback to complex oscillator. This warps complex oscillator shape
 * towards one of the corners.
 *
 * Submenu 2 includes 2 wavefolders:
 * - param B sets order for non-linear distortion based on Chebyshev polynomials. This can
 * radically change oscillator shape. See https://en.wikipedia.org/wiki/Chebyshev_polynomials
 * - param C sets wavefolding vector direction for second wavefolder
 * - param D adds wavefolding gain
 *
 * Parameters F and G can be used as outputs for modulation
 *
 * Audio input 1 is pitch CV, input 2 is FM. Pitch CV can be quantized if you
 * rebuild patch with quantizer enabled.
 **/

#include "SineOscillator.h"
#include "VoltsPerOctave.h"
#include "Quantizer.hpp"
#include "RoseOscillator.hpp"
#include "MultiProcessor.hpp"
#include "Wavefolder.hpp"
#include "ChebyshevPolynomial.hpp"
#include "DcBlockingFilter.h"
#include "ColourScreenPatch.h"
#include "ColorUtils.hpp"
#include "CircularBuffer.h"

#define BASE_FREQ 55.f
#define MAX_FM_AMOUNT 0.1f
#define MAX_RATIO 16
#define CHEB_ORDER 6
#define NUM_PIXELS 8192 // 6 bytes per pixel
#define SCREEN_SMOOTH 0.9f
#define NUM_HUE_STEPS 32
//#define OVERSAMPLE_FACTOR 2

#ifdef OVERSAMPLE_FACTOR
#include "Resample.h"
#endif

//#define QUANTIZER Quantizer12TET
// Uncomment to quantize

#define P_TUNE PARAMETER_A
#define P_HARMONICS PARAMETER_B
#define P_MULT PARAMETER_C
#define P_DIV PARAMETER_D
#define P_FEEDBACK1 PARAMETER_AA
#define P_FB2_DIR PARAMETER_AB
#define P_FB2_MAG PARAMETER_AC
#define P_FOLD PARAMETER_AD
#define P_DIR PARAMETER_AE
#define P_MAG PARAMETER_AF
#define P_CHAOS_X PARAMETER_F
#define P_CHAOS_LFO PARAMETER_G

using SmoothParam = SmoothValue<float>;
using StiffParam = StiffValue<float>;
using RatioQuantizer = Quantizer<MAX_RATIO, true>;

#ifdef OVERSAMPLE_FACTOR
// UpSampler* upsampler_pitch;
UpSampler* upsampler_fm;
DownSampler* downsampler_left;
DownSampler* downsampler_right;
AudioBuffer* oversample_buf;
#endif

using StereoWavefolder = MultiProcessor<Wavefolder<HardClipper>, 2>;
using StereoCheb = MultiProcessor<MorphingChebyshevPolynomial<false>, 2>;
using StereoDc = MultiProcessor<DcBlockingFilter, 2>;

static constexpr uint32_t hue_steps = 360 * NUM_HUE_STEPS;
static constexpr float hue_step = 1.0 / NUM_HUE_STEPS;

// We want this to be a multiple of 360 (degrees - to form circle) and a power
// of 2 for wrapping at integer number of buffers

class Pixel {
public:
    Pixel() : x(0), y(0), color(0) {};
    Pixel(uint16_t x, uint16_t y, uint16_t c)
        : x(x)
        , y(y)
        , color(c) {
    }
    Pixel(uint16_t c)
        : Pixel(0, 0, c) {
    }
    uint16_t x, y;
    uint16_t color;

    Pixel interpolate(const Pixel& other, uint8_t ratio) {
        return Pixel(x + (other.x - x) * ratio / 256, y + (other.y - y) * ratio / 256, color);
    }
};

using ColourBuffer = CircularBuffer<Pixel>;

class RoseColorPatch : public ColourScreenPatch {
private:
    RoseOscillator osc;
    SineOscillator mod_lfo;
    DcBlockingFilter dc_fm;
    ColourBuffer* pixels;
    uint16_t screen_radius = 0;
    uint16_t screen_center_x = 0, screen_center_y = 0;
    float attr_x = 0.0, attr_y = 0.0;
    const float attr_a = -0.827;
    const float attr_b = -1.637;
    const float attr_c = 1.659;
    const float attr_d = -0.943;
    //Pixel prev_px;
    ComplexFloat cmp_offset;
    ComplexFloat sample;
    uint32_t hue = 0;
#ifdef QUANTIZER
    QUANTIZER quantizer;
#endif
#ifdef OVERSAMPLE_FACTOR
    // UpSampler* upsampler_pitch;
    UpSampler* upsampler_fm;
    DownSampler* downsampler_left;
    DownSampler* downsampler_right;
    AudioBuffer* oversample_buf;
#endif
    bool isModeA = false, isModeB = false;
    float fm_ratio;
    float fm_amount;
    VoltsPerOctave hz;
    // QuadraturePhaser* phaser;
    StereoWavefolder wavefolder;
    StereoCheb cheb;
    StereoDc dc;
    float lfo_sample;
    SmoothParam p_feedback = SmoothParam(0.01);
    StiffParam p_divisor = StiffParam(1.f / float(MAX_RATIO + 1));
    StiffParam p_multiplier = StiffParam(1.f / float(MAX_RATIO));
    SmoothParam p_ratio = SmoothParam(0.01);
    SmoothParam p_harmonics = SmoothParam(0.01);
    SmoothParam p_fb_direction = SmoothParam(0.01);
    SmoothParam p_fb_magnitude = SmoothParam(0.01);
    SmoothParam p_fold = SmoothParam(0.01);
    SmoothParam p_direction = SmoothParam(0.01);
    SmoothParam p_magnitude = SmoothParam(0.01);

public:
    RoseColorPatch() {
        mod_lfo.setSampleRate(getSampleRate() / getBlockSize());
        mod_lfo.setFrequency(0.75);
#ifdef OVERSAMPLE_FACTOR
        osc.setSampleRate(getSampleRate() * OVERSAMPLE_FACTOR);
#else
        osc.setSampleRate(getSampleRate());
#endif
        osc.setFrequency(BASE_FREQ);
        registerParameter(P_TUNE, "Tune");
        setParameterValue(P_TUNE, 0.5f);
        registerParameter(P_HARMONICS, "Harmonics");
        setParameterValue(P_HARMONICS, 1.f);
        registerParameter(P_MULT, "Multiplier");
        setParameterValue(P_MULT, 0.25f);
        registerParameter(P_DIV, "Divisor");
        setParameterValue(P_DIV, 0.25f);
        registerParameter(P_FEEDBACK1, "Feedback1");
        setParameterValue(P_FEEDBACK1, 0.5f);
        registerParameter(P_FB2_MAG, "Feedback2 Magnitude");
        setParameterValue(P_FB2_MAG, 0.f);
        registerParameter(P_FB2_DIR, "Feedback2 Phase");
        setParameterValue(P_FB2_DIR, 0.f);
        registerParameter(P_FOLD, "Chebyshaper");
        setParameterValue(P_FOLD, 0.f);
        registerParameter(P_DIR, "Fold Direction");
        setParameterValue(P_DIR, 0.f);
        registerParameter(P_MAG, "Fold Magntitude");
        setParameterValue(P_MAG, 0.f);
        registerParameter(P_CHAOS_X, "ChaosX>");
        registerParameter(P_CHAOS_LFO, "ChaoLFO>");

        p_feedback.lambda = 0.96;
        p_multiplier.delta = (1.f / float(MAX_RATIO + 1));
        p_divisor.delta = (1.f / float(MAX_RATIO + 2));
        p_harmonics.lambda = 0.96;
        p_fb_direction.lambda = 0.96;
        p_fb_magnitude.lambda = 0.96;
        p_fold.lambda = 0.96;
        p_direction.lambda = 0.96;
        p_magnitude.lambda = 0.96;

#ifdef OVERSAMPLE_FACTOR
        // upsampler_pitch = UpSampler::create(1, OVERSAMPLE_FACTOR);
        upsampler_fm = UpSampler::create(1, OVERSAMPLE_FACTOR);
        downsampler_left = DownSampler::create(1, OVERSAMPLE_FACTOR);
        downsampler_right = DownSampler::create(1, OVERSAMPLE_FACTOR);
        oversample_buf = AudioBuffer::create(2, getBlockSize() * OVERSAMPLE_FACTOR);
#endif

        setButton(BUTTON_A, false, 0);
        setButton(BUTTON_B, false, 0);
        cheb.get(0).setMaxOrder(CHEB_ORDER);
        cheb.get(1).setMaxOrder(CHEB_ORDER);
        cheb.get(0).setOffset(1);
        cheb.get(1).setOffset(1);

        pixels = ColourBuffer::create(NUM_PIXELS);
    }

    ~RoseColorPatch() {
        ColourBuffer::destroy(pixels);
#ifdef OVERSAMPLE_FACTOR
        // UpSampler::destroy(upsampler_pitch);
        UpSampler::destroy(upsampler_fm);
        DownSampler::destroy(downsampler_left);
        DownSampler::destroy(downsampler_right);
        AudioBuffer::destroy(oversample_buf);
#endif
    }

    void buttonChanged(PatchButtonId bid, uint16_t value, uint16_t samples) override {
        switch (bid) {
        case BUTTON_A:
            if (value)
                isModeA = !isModeA;
            setButton(BUTTON_A, isModeA, 0);
            if (isModeA) {
                setButton(BUTTON_B, false, 0);
                isModeB = false;
            }
            break;
        case BUTTON_B:
            if (value)
                isModeB = !isModeB;
            setButton(BUTTON_B, isModeB, 0);
            if (isModeB) {
                setButton(BUTTON_A, false, 0);
                isModeA = false;
            }
            break;
        default:
            break;
        }
    }

    void processScreen(ColourScreenBuffer& screen) {
        // This zooms in visualization when patch starts
        screen_radius = (float)screen_radius * SCREEN_SMOOTH +
            float(std::min(screen.getWidth(), screen.getHeight()) / 2) *
                (1.f - SCREEN_SMOOTH);
        screen_center_x = screen.getWidth() / 2;
        screen_center_y = screen.getHeight() / 2;

        //uint16_t hue_16_bit = RGB888toRGB565(HSBtoRGB(hue_step * hue, 1.f, 1.f));
        uint16_t hue_16_bit = RED;

        for (size_t i = 0; i < NUM_PIXELS; i++) {
            Pixel px = pixels->readAt(i);
//            uint16_t hue_16_bit = RGB888toRGB565(HSBtoRGB(i * 360.f * hue_step, 1.f, 1.f));
            
            screen.setPixel(px.x, px.y, hue_16_bit);//
            //hue_16bit);
        }
        //hue = ++hue % hue_steps;
/*        
        screen.print(20, 20, "#");
        screen.print(msg_itoa(hue_16_bit, 16));
        screen.print(" ");
        screen.print(msg_itoa(HSBtoRGB(hue_step * hue, 1.f, 1.f), 16));

        screen.print(" ");
        screen.print((int)hue_16_bit >> 11);

        screen.print(" ");
        screen.print((int)(hue_16_bit >> 5) & 0b111111);

        screen.print(" ");
        screen.print((int)(hue_16_bit & 0b11111));
*/
    }

    void processAttractor(float chaos) {
        float old_x = attr_x, old_y = attr_y;
        attr_x = sin(attr_a * old_y) - cos(attr_b * old_x);
        attr_y = sin(attr_c * old_x) - cos(attr_d * old_y);
        lfo_sample = mod_lfo.generate(attr_y * chaos * 0.02);
    }

    void processAudio(AudioBuffer& buffer) {
        // CV output
        processAttractor(1.0);
        setParameterValue(P_CHAOS_X, attr_x * 0.5 + 0.5);
        setParameterValue(P_CHAOS_LFO, lfo_sample * 0.5 + 0.5);
        setButton(BUTTON_C, lfo_sample >= 0.0);

        FloatArray left = buffer.getSamples(LEFT_CHANNEL);
        FloatArray right = buffer.getSamples(RIGHT_CHANNEL);
        dc_fm.process(right, right);
        right.multiply(MAX_FM_AMOUNT);

        // Tuning
        float tune = -4.0 + getParameterValue(P_TUNE) * 4.0;
#ifndef QUANTIZER
        hz.setTune(tune);
#endif
// Carrier / modulator frequency
#ifdef QUANTIZER
        float volts = quantizer.process(tune + hz.sampleToVolts(left[0]));
        float freq = hz.voltsToHertz(volts);
#else
        float freq = hz.getFrequency(left[0]);
#endif

        p_harmonics.update(getParameterValue(P_HARMONICS));
        p_multiplier.update(getParameterValue(P_MULT));
        p_divisor.update(getParameterValue(P_DIV));
        p_ratio.update(getParameterValue(P_MULT));
        int divisor = (MAX_RATIO + 1) * p_divisor.getValue();
        if (divisor == 0) {
            osc.setRatio(p_ratio.getValue() * MAX_RATIO);
        }
        else {
            int multiplier = MAX_RATIO * p_multiplier.getValue() + 1;
            osc.setRatio(float(multiplier) / float(divisor));
        }

        p_feedback.update(getParameterValue(P_FEEDBACK1) * 2.f - 1.f);
        p_fb_direction.update(getParameterValue(P_FB2_DIR));
        p_fb_magnitude.update(getParameterValue(P_FB2_MAG));

        p_fold.update(getParameterValue(P_FOLD));
        p_direction.update(getParameterValue(P_DIR));
        p_magnitude.update(getParameterValue(P_MAG));

        osc.setFrequency(freq);
        osc.setHarmonics(p_harmonics.getValue());
        osc.setFeedback1(p_feedback.getValue());
        osc.setFeedback2(
            p_fb_magnitude.getValue(), p_fb_direction.getValue() * M_PI * 4.f);

        // right.add(left);

#ifdef OVERSAMPLE_FACTOR
        upsampler_fm->process(right, oversample_buf->getSamples(1));
        AudioBuffer& audio_buf = *oversample_buf;
#else
        AudioBuffer& audio_buf = buffer;
#endif
        osc.generate(audio_buf, audio_buf.getSamples(1));

        // Chebyshev wavefolder
        float fold = p_fold.getValue();
        cheb.get(0).setMorph(fold);
        cheb.get(1).setMorph(fold);
        cheb.process(audio_buf, audio_buf);

#ifdef OVERSAMPLE_FACTOR
        downsampler_left->process(oversample_buf->getSamples(0), left);
        downsampler_right->process(oversample_buf->getSamples(1), right);
#endif

        // Complex wavefolder - oversampling is not necessary, algo suppresses aliasing
        float offset_phase = p_direction.getValue() * M_PI;
        float offset_mag = p_magnitude.getValue() * 3;
        cmp_offset.setPolar(offset_mag, offset_phase);

        left.multiply(1.f + abs(cmp_offset.re));
        right.multiply(1.f + abs(cmp_offset.im));
        wavefolder.process(buffer, buffer);

        dc.process(buffer, buffer);

        for (size_t i = 0; i < buffer.getSize(); i += 4) {
            Pixel new_px(
                screen_center_x + int16_t(left[i] * screen_radius),
                screen_center_y + int16_t(right[i] * screen_radius),
                HSBto565(1.f, 1.f, 1.f));
                /*
            pixels->write(prev_px.interpolate(new_px, 0x20));
            pixels->write(prev_px.interpolate(new_px, 0x40));
            pixels->write(prev_px.interpolate(new_px, 0x60));
            pixels->write(prev_px.interpolate(new_px, 0x80));
            pixels->write(prev_px.interpolate(new_px, 0xa0));
            pixels->write(prev_px.interpolate(new_px, 0xc0));
            */
            pixels->write(new_px);
            //prev_px = new_px;
        }
//        hue %= hue_steps;
    }
};
#endif
